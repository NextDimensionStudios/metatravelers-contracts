// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";

contract MetaTravelers is ERC721Enumerable, ERC721Pausable, ERC721Burnable, Ownable {
    using Counters for Counters.Counter;
    using Strings for uint256;

    uint256 public maxSupply = 7777;

    Counters.Counter private _tokenIdTracker;
    string private _baseTokenURI;
    uint256 private constant PRICE = .123 ether;
    uint256 private constant MAX_QUANTITY = 3;

    constructor (
        string memory name,
        string memory symbol,
        string memory baseTokenURI
    )
    ERC721(name, symbol) {
        _baseTokenURI = baseTokenURI;
    }

    event AssetsMinted(address owner, uint256 quantity);

    /**
    * @dev Update the base token URI for returning metadata
    */
    function setBaseTokenURI(string memory baseTokenURI) external onlyOwner {
        _baseTokenURI = baseTokenURI;
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     */
    function mint(address to, uint256 quantity) external payable {
        require( totalSupply() + quantity <= maxSupply, "Purchase exceeds max supply");
        require(quantity <= MAX_QUANTITY, "Order exceeds max quantity");
        require(msg.value >= PRICE * quantity, "Ether value sent is not correct");

        for(uint256 i=0; i<quantity; i++){
            _mint(to, _tokenIdTracker.current());
            _tokenIdTracker.increment();
        }
        emit AssetsMinted(to, quantity);
    }

    /**
     * @dev Used to withdraw funds from the contract
     */
    function withdraw() public onlyOwner() {
        uint256 balance = address(this).balance;
        payable(_msgSender()).transfer(balance);
    }
    
    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token.");
        return bytes(_baseTokenURI).length > 0 ? string(abi.encodePacked(_baseTokenURI, tokenId.toString())) : "";
    }   

    /**
     * @dev Used to pause contract minting per ERC721Pausable
     */
    function pause() external onlyOwner() {
        _pause();
    }

    /**
     * @dev Used to unpause contract minting per ERC721Pausable
     */
    function unpause() external onlyOwner() {
        _unpause();
    }
    
    /**
     * @dev Required due to inheritance
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }     

    /**
     * @dev Required due to inheritance
     */
    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }   
}